#include <string>
#include <vector>
#include <algorithm>

#include <iostream>

using namespace std;

long long solution(int n, vector<int> times) {
    unsigned long long answer = 0;

    unsigned long long left = 1;
    unsigned long long right = *max_element(times.begin(), times.end()) * n;

    while(left <= right)
    {
        unsigned long long mid = (left + right) / 2;
        unsigned long long people_num = 0;
        int temp = -1;
        for(int time : times)
        {
            people_num += mid/time;
            if(mid % time == 0) temp++;
        }
        if(temp >= 0)
            people_num -= temp;

        
        if (people_num >= n)
        {
            if(people_num == n)
            {
                if(answer == 0)
                    answer = mid;
                else
                    answer = min(answer, mid);
            }
            right = mid - 1;
        }
        else if(people_num < n)
            left = mid + 1;
        
        if(left > right && answer == 0)
            answer = mid;
    }
    return answer;
}


// https://programmers.co.kr/learn/courses/30/lessons/43238

/*
생각
새로운 배열을 생성
->이 배열은 심사관이 총 일한 시간을 가지게 됨 long long 써야할 듯
모든 시간은 0을 초기화 값으로 가지고 있음
심사관을 선택할 때에는
현재 심사관이 진행한 총 심사 시간 + 내가 진행할 심사시간 에 대해서 제일 적은 수를 선택함
ex)
6명의 심사 대기 인원
  [7 10]
1 [0, 0] -> 0+7 < 0+10       | 7을 선택
------
2 [7, 0] -> 7+7 > 0+10       | 10을 선택
------
3 [7, 10] -> 7+7 < 10+10     | 7을 선택
------
4 [14, 10] -> 14+7 > 10+10   | 10을 선택
------
5 [14, 20] -> 14+7 < 20+10   | 7을 선택
------
6 [21, 20] -> 21+7 < 20+10   | 7을 선택
------
[28, 20] // 총 6명의 인원의 심사를 받았으며, value가 가장 큰 28이 답이 됨
==========================================
또는 배열에는 총 시간이 아닌 담당한 인원의 수를 가지게 해도 될 듯
[0, 0]
[1, 0]
[1, 1]
[2, 1]
[2, 2]
[3, 2]
[4, 2]
단, 이땐 시간 * 인원수에 대한 가장 큰 값을 따로 저장하거나 구해야함

위에 두 방법은 너무 오랜 시간이 걸릴 것으로 예상이 됨 총 사람의 인원이 1e9, 심사위원의 수는 1e5
1e9 * 1e5 = 1e14 너무너무너무 오래걸림
========
어떤 방법이던 28이라는 수가 나와야함
[7, 10], 6이라는 수를 가지고 28을 만드는 법

반대로 생각해보자, 사람을 심사원에 보내 시간을 구하는 방법이 있지만
반대로 시간을 구해서 사람 인원을 확인하는 방법도 있을 것

가장 가깝다고 생각되는 시간(초기화 값)은 최소시간과 최대 시간의 중간 값일 것
최솟값은 1, 최댓값은 6 * 10
61/2 = 30.xx 정수형이기 때문에 30
30분이라는 시간을 예측해서 각 심사원이 담당하는 사람의 수를 확인
[7, 10] 30/7 = 4 + 0.xx, 30/10 = 3
[4, 3], 총 7명의 사람을 담당한 시간이 됨 그러나 현재 인원은 6명이기에 부적절함
30분은 7명을 심사할 수 있는 시간이기에 6명을 심사한 시간은 30분보다 낮을 것
-> 이러면 최솟값은 1분, 최댓값은 30-1분을 가지게됨

다시 반복, 1 + 29 = 30   30/2 = 15분
15/7 = 2.  15/10 = 1.
[2, 1] 총 3명의 사람을 심사할 수 있는 시간임
15분은 3명을 심사할 수 있는 시간이기에, 6명을 심사한 시간은 15분보다 클 것
-> 최솟값은 15+1, 최댓값은 29가 될 것

반복하다가 최솟값 >= 최댓값이 되는 순간 반복문은 종료

예외 처리1
27분일 경우 -> [3, 2]
28분일 경우 -> [4, 2]
29분일 경우 -> [4, 2] 
30분일 경으 -> [4, 3]
28, 29분일 경우 둘다 동일하게 6명의 인원이 나옴
같은 결과가 나오는 시간 중 가장 작은 시간을 선택해야 함, 또는 저장해놓으면 됨

6, 8, 10
10
6 0 0
6 8 0
6 8 10
12 8 10
12 16 10
18 16 10
18 16 20
24 16 20
24 24 20
30 24 20
*/
